# 縮圖元件設計筆記（相框 vs 畫布、縮放與座標還原）

> 外層像相框（決定縮圖佔多大格），內層像畫布（固定 1000×562.5 的座標系），只縮放畫布，不動相框。

## 1) 核心觀念（先記住這兩句）

* **外層＝相框**：只負責「占位/排版/裁切」尺寸（`width/height/overflow`）。
* **內層＝畫布**：固定座標系（例如 `1000 × 562.5`），**只縮放內容**（`transform: scale(...)`），`transform-origin: 0 0`。

---

## 2) 元件結構與屬性職責

```vue
<template>
  <div class="thumbnail-slide"
       :style="{ width: size+'px', height: size*viewportRatio+'px' }">
    <div class="elements"
         :style="{
           width: viewportSize + 'px',
           height: viewportSize * viewportRatio + 'px',
           transform: `scale(${scale})`,
           transformOrigin: '0 0',
         }"
         v-if="visible">
      <div class="background" :style="backgroundStyle"></div>
      <ThumbnailElement
        v-for="(element, index) in slide.elements"
        :key="element.id"
        :elementInfo="element"
        :elementIndex="index + 1"
      />
    </div>
    <div class="placeholder" v-else>加载中 ...</div>
  </div>
</template>

<script setup lang="ts">
const viewportSize = 1000                // 內容座標系寬度
const viewportRatio = 0.5625             // 16:9
const props = defineProps<{ size: number }>()
const scale = computed(() => props.size / viewportSize)
</script>
```

* `.thumbnail-slide`（相框）：決定縮圖在列表/網格中的**外觀尺寸**與排版空間。
* `.elements`（畫布）：維持固定的**內容座標系**（1000×562.5），以 `transform: scale(scale)` 把內容縮到相框內。

---

## 3) 為何 **不要** 把 `width/height/transform` 移到外層？

1. **座標穩定**
   內容世界永遠是 `1000×562.5`，子元素座標不需重算。用內層縮放，**座標映射簡單**。
2. **只縮內容，不縮外殼**
   邊框、陰影、placeholder 不會被拉扯變形；交互熱區更一致。
3. **效能更友善**
   內層 `transform` 多由 GPU 合成；外層若縮放，容易牽動父層排版（reflow/重繪風險更高）。
4. **事件/光標精準**
   以內層為唯一縮放源，滑鼠座標換算規則固定（見第 5 節），不會出現雙重尺度。

> 例外：**單張純展示**、外殼完全沒有邊框/陰影/交互、也不在列表中排版時，縮外層可勉強接受；一旦需要 hover/選取/對齊線 → 回到縮內層。

---

## 4) 分批載入（避免卡頓）的關鍵

你的 Hook（`slidesLoadLimit` + `setTimeout`）做的是**漸進式掛載**：

* 初始載入部分縮圖（例如 50 張），延遲一段時間再批次加 20 張，直到全部載入。
* 好處：把一次性的**大量 DOM/渲染工作**拆成數個小批次，降低主執行緒尖峰，捲動更順。
* 搭配 `v-if="visible"`：不可見時不渲染 `.elements`，縮小初始成本。

> 一句話：**少量多批次渲染 + 只縮內容層**，兩者合用就能有效避免卡頓。

---

## 5) 滑鼠座標還原到原圖（費曼級直白）

* 你看到的是**縮小後**的畫面；要回到原始畫布（1000×562.5），**除以縮放比**。
* 前提：`transform-origin: 0 0`

**公式**

```
x_world = x_screen / scale
y_world = y_screen / scale
```

* `x_screen/y_screen`：螢幕上的點擊位置，相對於 `.elements` 左上角（用 `getBoundingClientRect()` 算）。
* `x_world/y_world`：對應原圖座標（1000×562.5 座標系）。

**範例**

* `scale = 0.2`，你在顯示圖的 `(50, 30)` 點擊
  → 原圖座標 = `(50/0.2, 30/0.2) = (250, 150)`

**Vue 實作骨架**

```ts
function toWorldCoords(e: PointerEvent, el: HTMLElement, scale: number) {
  const rect = el.getBoundingClientRect()
  const x_screen = e.clientX - rect.left
  const y_screen = e.clientY - rect.top
  return { x: x_screen / scale, y: y_screen / scale }
}
```

---