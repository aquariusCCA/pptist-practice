> 目的：用**固定的邏輯座標系**（寬度基準 + 長寬比）解耦「實際容器尺寸」與「版面/互動邏輯」，確保任何裝置上**構圖一致、互動穩定**。

# 一、核心概念

* **邏輯寬度 `viewportSize`**

  * 以 `1000` 當作「畫布的邏輯寬度單位」。
  * 之後所有元素（文字框、圖形、對齊線、吸附網格、滑鼠座標換算）都以這個固定寬度為基準來描述與計算。

* **長寬比 `viewportRatio`（高/寬）**

  * 例：`0.5625`，即 `9/16`，代表 **寬 : 高 = 16 : 9**。
  * 高度 = `寬度 × (高/寬)`。

* **縮放倍率 `scale`**

  * 把**容器實際寬度**轉為**渲染倍率**：`scale = 容器實際寬度 / 邏輯寬度`。
  * 渲染尺寸 = 邏輯尺寸 × `scale`；事件座標（像素） ↔ 邏輯座標需要 ÷ 或 × `scale`。

---

# 二、為何這樣設計（價值主張）

1. **解耦與一致性**：邏輯世界不變；裝置只改變 `scale`。
2. **互動穩定**：拖曳/縮放/旋轉以固定數值計算；多人協作座標一致。
3. **模板與匯出**：16:9 模板構圖不變；匯出時只挑輸出像素與 `scale`。
4. **效能與可控**：大量運算在固定邏輯空間完成，渲染階段統一乘 `scale`。

---

# 三、16:9 的正確理解與計算

* **16:9 是「寬 : 高」**

  * 若固定寬度 `W = 1000`，則 `H = W × (9/16) = 562.5`。
  * **關鍵：**`9/16` 是 **高/寬**，因為你是用「寬」去推「高」。

> 記憶口訣
>
> * 固定寬度 → `height = width × (高/寬)` → `× 9/16`（對 16:9）
> * 固定高度 → `width  = height × (寬/高)` → `× 16/9`（對 16:9）

---

# 四、實作片段
## 1️⃣ 不縮放——原尺寸預覽

* `.elements` 寬：1000 px
* `.elements` 高：562.5 px
* `transform: scale(1)`

> 所有子元素（背景、文字框、圖片…）都放在 1000 × 562.5 的座標系內。這就是 PPTist 裡看到的「真實尺寸」。

## 2️⃣ 產生縮略圖（寬 200 px）

1. **目標寬度**（外部給的 `props.size`） = **200 px**
2. **縮放因子** `scale` = 200 ÷ 1000 = **0.2**
3. `.thumbnail-slide`（包裝容器）

   * 寬：200 px
   * 高：200 × 0.5625 = **112.5 px**
4. `.elements` 仍宣告寬 1000、高 562.5，但一行 CSS 把它縮小：

   ```css
   transform: scale(0.2);   /* 1000 × 0.2 = 200，562.5 × 0.2 = 112.5 */
   transform-origin: 0 0;   /* 從左上角開始縮，座標不跑位 */
   ```

> 結果：所有子元素 **自動** 跟著 0.2 等比縮放，縮略圖完工——寬 200、高 112.5，比例依舊 16:9，無需逐項改 style。

## 3️⃣ 再放大到劇院模式（寬 1920 px）

* 目標寬：**1920 px**
* `scale` = 1920 ÷ 1000 = **1.92**
* 容器高：1920 × 0.5625 = **1080 px**
* 子元素 `scale(1.92)` → 每個像素放大 1.92 倍，仍然 16:9。

---